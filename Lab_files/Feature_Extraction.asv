%% DT2119 - Speech and speaker recognition - Lab 1 - Feature extraction

%%
% Mel Frequency Cepstral Coefficients (MFCCs) are coefficients used in
% Speech recognition based on human auditive perception. These coefficients
% come from the need, in the field of aoutonomous audio recognition, to
% extract the main features of an audio signal while discarding all the
% irrelevant features that will make the recognition harder to achieve
% (background noise, emotion ...)
%
% The sounds generated by a human depend on the shape of the vocal tract,
% position of the tongue, teeth, lips etc. Then, if we can determine this
% shape accurately, the phoneme that was produced will be easy to identify.
% The main objetive of the MFCC it to accurately represent the envelope of
% the short time power spectrum in order to stablish the shape of the vocal
% tract. Consisting then of one of the most important features in Speech
% recognition

%%
% First we need to prepare the workspace and load the data set
clear all;
close all; 
load('tidigits.mat')
load('example.mat')


%% 1.1 Enframe the audio signal
%
% The purpose of this first step is to cut the original sample in many
% smaller ones. In this case, we want windowframes of 20 ms with a shift
% between windows of 10 ms. As the shift is smaller than the window, the
% computed frames will have shared parts between each other
%
% _*Compute the number of samples per frame and shift*_
% 
% The sampling rate is S = 20 kHz. Then the period is $T = 1/S$. 
% We have that: 
%
% Length of the window: $0.02T = 400$ samples
% Length of the shift: $0.01T = 200$ samples


winlen = 400;
winshift = 200; 

%%
% Now is time to check the performance of the written function. To do so,
% the function is evaluated with the example's structure data set, and compared to the
% frames given in the example's structure frames. The output generated must
% be identical to the frames stored in the data structure in example.

samples = example{1,1}.samples; 
test = example{1,1}.frames';
frames = enframe(samples,winlen,winshift);
% As the image have to be plotted in with the same orientation as in the
% test data then
frames = frames(:,1:400)'; 
%% 
% The comparison is shown in the folowwing figure. 
subplot(2,1,1)
imagesc(frames)
colormap jet
title(' Enframe function output')
subplot(2,1,2)
imagesc(test)
colormap jet
title(' Test frames set')

%%
% To check the performance numerically, we will substract the test data
% from the output and get the total differences between both of them

subs = test - frames;
Enframe_error = sum(sum(subs))
%% 1.2 Pre-emphasys
%
% The main objetive of this function is to compesate the 6dB/octave that
% are dropped due to the radiation at the lips. This funcion is: 
%
% $y[n] = x[n] - ax[n-1]$
%
% Being the coefficientes  $A = 1$ and $B = [1 -a]$.
%
% The purpose of substracting the main part of the previous input is
% because the important features are in the higher frequencias, remaining
% the lower frequencies almost unchenged. Therefor, doing the substraction
% we discard the similar parts of the signal analyzing only the higher
% frequencies, where the important features are. 
%
% We have now to check the performance of the written function. To do so,
% we have to compare the output of this function with the test data. 

a = 0.97;
preemph = preemp(frames,a);
test_preem = example{1,1}.preemph';

%% 
% The comparison is shown in the folowwing figure. 
figure;
subplot(2,1,1)
imagesc(preemph)
colormap jet
title(' Preemp function output')
subplot(2,1,2)
imagesc(test_preem)
colormap jet
title(' Test preemphashis set')

%%
% To check the performance numerically, we will substract the test data
% from the output and get the total differences between both of them

subs = test_preem - preemph;
Preemphasis_error = sum(sum(subs))

%% 1.3 Hamming window
%
% The use of the Hamming window is justified as it emphasizes the center of
% the window, improving this way the values of the Fourier Transfer
% Function. The sidelobes are reduced, being the center lobe much important
% than these side lobes. 
%
% The Hamming window is used in order to reduce the discontinuities in the
% edges of the frames, focusing in the main(centered) frequencies. 
%
% The function windowing that applies the hamming window is implemented and
% used on the pre emphasized frames. 

[windowed_frames, window] = windowing(preemph);
test_windowed = example{1,1}.windowed';
%%
% The shape of the Hamming window used is
% figure;
% <<FIGURE_WINDOW.BMP>>

%%
% We have now to check the performance of the written function. To do so,
% we have to compare the output of this function with the test data.
figure;
subplot(2,1,1)
imagesc(windowed_frames)
colormap jet
title(' Windowing function output')
subplot(2,1,2)
imagesc(test_windowed)
colormap jet
title(' Test windowing set')

%%
% To check the performance numerically, we will substract the test data
% from the output and get the total differences between both of them

subs = test_windowed - windowed_frames;
window_error = sum(sum(subs))

%%
% We can observe that the error is not exactly cero but is sufficiently
% small enough. The insignificant difference is probably due to the use of
% Matlab instead of Python. 

%% 1.4 Fast Fourier Transform
%
% The powerSpectrum function is developed in this section. This function
% performs the Fast fourier Transform to the windowed frames and a then
% applies a squared power to the modulus. 
%
% As now er are in the frequency domain, it is interesting what the max
% frequency will be: 
%
% $$f_{max}=\frac{f_{samp}}{2}=\frac{20000}{2} = 10 kHz$$
nfft = 512;
FFT_frame = powerSpectrum(windowed_frames,nfft);
test_FFT = example{1,1}.spec';

%%
% We have now to check the performance of the written function. To do so,
% we have to compare the output of this function with the test data.
figure;
subplot(2,1,1)
imagesc(FFT_frame)
title(' Power Spectrum output')
subplot(2,1,2)
imagesc(test_FFT)
title(' Test Power Spectrum set')

%%
% To check the performance numerically, we will substract the test data
% from the output and get the total differences between both of them

subs = test_FFT - FFT_frame;
FFT_error = sum(sum(subs))
figure
%%
% As expected, the error is not 0 as we get the errors from the previous
% step, but squared. Still the error is too small to be considered.

%% 1.5 Mel filterbank log spectrum
%
% A filter bank is a set a filters. In the case of the Mel fiterbank, these
% filters are triangles, in which the first filter only keeps low
% frequencies while the next filters slowly shift to higher frequencies and
% the amplitude of the triangles decrease, and they get wider. 
%
% This decreased amplitude try to represent the human ear system, as the
% higher the frequencies, the more difficult discern differences. This is
% why the triangles get wider: we need a bigger filter as the resolution is
% less precise.
%
% The sum of the energy in every filter is computed. We need to take the
% log of this energy due to the log property of sound: to double the sound
% we need 8 times more energy. 

sampling_freq = 20000;
[melSpec_frames, filterBank] = logMelSpectrum(FFT_frame,sampling_freq);
test_melSpec = example{1,1}.mspec';

%%
% The Mel filter bank computed is the one that follows
figure('Name','Mel Frequency Filter Bank')
plot(filterBank')
axis([0, 178,  0, max(max(filterBank))])
title('Mel-filterbank')
%%
% We have now to check the performance of the written function. To do so,
% we have to compare the output of this function with the test data.
figure;
subplot(2,1,1)
imagesc(melSpec_frames)
title(' Power Spectrum output')
colormap jet
subplot(2,1,2)
imagesc(test_melSpec)
title(' Test Power Spectrum set')
colormap jet

%%
% To check the performance numerically, we will substract the test data
% from the output and get the total differences between both of them
subs = test_melSpec - melSpec_frames;
melSpec_error = sum(sum(subs))

%% 1.6 Cosine Transform
%
% The Discrete Cosine Transform perform a similar operation than the
% Fourier transform: they both descompose a discrete-time vector in a sum
% of scaled-and-shifted basis functions. The main difference is that the
% DCT uses only cosines as the Basis function. 

number_of_coefficients = 13;
[CT_frames] = cepstrum(melSpec_frames, number_of_coefficients);
test_CT = example{1,1}.mfcc';

%%
% We have now to check the performance of the written function. To do so,
% we have to compare the output of this function with the test data.
figure;
subplot(2,1,1)
imagesc(CT_frames)
title(' Cosine transformation output')
colormap jet
subplot(2,1,2)
imagesc(test_CT)
title(' Test Cosine transformation set')
colormap jet

%%
% To check the performance numerically, we will substract the test data
% from the output and get the total differences between both of them
subs = test_CT - CT_frames;
CT_error = sum(sum(subs))

%% 1.7 Liftering
%
% The Discrete Cosine Transform perform a similar operation than the
% Fourier transform: they both descompose a discrete-time vector in a sum
% of scaled-and-shifted basis functions. The main difference is that the
% DCT uses only cosines as the Basis function. 
[Lift_frames] = lifter_matlab(CT_frames);
test_Lifter = example{1,1}.lmfcc';
%%
% We have now to check the performance of the written function. To do so,
% we have to compare the output of this function with the test data.
figure;
subplot(2,1,1)
imagesc(Lift_frames)
title(' Cosine transformation output')
colormap jet
subplot(2,1,2)
imagesc(test_Lifter)
title(' Test Cosine transformation set')
colormap jet

%%
% To check the performance numerically, we will substract the test data
% from the output and get the total differences between both of them
subs = test_Lifter - Lift_frames;
Lift_error = sum(sum(subs))

%% 1.8 Calculation of the MFCCs for each uterance
gender = [];
speaker = [];
digits = [];
MFCCs = cell(1,44);
mSpec = cell(1,44);
MFCCs_straight = cell(1,44);
mSpec_straight = cell(1,44);
MFCCs_concatenate = [];
mSpec_concatenate = [];
for i = 1:size(tidigits,2)
    [MFCCs_straight{i} mSpec_straight{i}] = mfcc(tidigits{1,i}.samples);
    MFCCs{i} = MFCCs_straight{i}';
    MFCCs_concatenate = vertcat(MFCCs_concatenate,MFCCs{i});
    mSpec{i} = mSpec_straight{i}';
    mSpec_concatenate = vertcat(mSpec_concatenate,mSpec{i});
    digits =[digits; tidigits{1,i}.digit,tidigits{1,i}.gender(1)];
    gender = [gender tidigits{1,i}.gender(1)];
    speaker = [speaker; tidigits{1,i}.speaker];
end

%% 2. Study the correlation between uterances
figure
corMFCCs = corrcoef(MFCCs_concatenate);
imagesc(flipdim(corMFCCs ,1));           %# vertical flip)
axis equal
colormap winter
colorbar

figure
corMspec = corrcoef(mSpec_concatenate);
imagesc(flipdim(corMspec ,1));           %# vertical flip)
axis equal
colormap winter
colorbar

%% 3. Distances
%
% 
D = zeros(size(tidigits,2),size(tidigits,2));
for i = 1:size(tidigits,2)
    for j =  1:size(tidigits,2)
        a = MFCCs{i};
        b = MFCCs{j};
        local_dist = localDistances(a, b);
        D(i,j) = dtw(local_dist);
    end
end

%% Plotting and axplantation
figure(1);
imagesc(D)
% colormap default(1000))
colormap(jet(60))
xticks(1:44)
xticklabels(digits)
yticks(1:44)
yticklabels(digits)
print('Distances','-dpng');
%% Linkage clustering
Clusters = linkage(D,'complete');
[H,T,outperm] = dendrogram(Clusters, 0);
% labelss = digits(outperm)
labels = tidigit2labels(tidigits);
xticklabels(labels(outperm,:))
set(gca,'XTickLabelRotation',)